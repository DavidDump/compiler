#include <stdio.h>  // fopen(), fseek(), ftell(), fread(), fclose(), printf(), 
#include <string.h> // strlen(), memcpy()
#include <assert.h> // assert()

#include "codegen.h"
#include "types.h"
#include "parser.h"
#include "lexer.h"
#include "string.h"
#include "common.h"

#define ARENA_IMPLEMENTATION
#include "arena.h"

String EntireFileRead(Arena* mem, const char* filePath){
    FILE* f = fopen(filePath, "rb");
    
    if(f){
        fseek(f, 0, SEEK_END);
        int fileSize = ftell(f);
        fseek(f, 0, SEEK_SET);
        
        char* fileBuffer = arena_alloc(mem, fileSize * sizeof(char));
        fread(fileBuffer, sizeof(char), fileSize, f);
        fclose(f);

        String str = {
            .str = fileBuffer,
            .length = fileSize,
        };
        return str;
    }else{
        printf("[ERROR] Failed to open file: %s\n", filePath);
        return (String){0};
    }
}

bool EntireFileWrite(const char* filePath, StringChain data){
    FILE* f = fopen(filePath, "wb");

    if(f){
        StringNode* current = data.first;
        while(current != NULL){
            fprintf(f, "%.*s", current->str.length, current->str.str);
            current = current->next;
        }
        fclose(f);
        return TRUE;
    }else{
        printf("[ERROR] Failed to open file: %s\n", filePath);
        return FALSE;
    }
}

// 
// Main
// 

void usage(char* exePath){
    printf("Usage: %s [ARGS] -i <filepath>\n", exePath);
    printf("Supported args:\n");
    printf("    --output -o <filepath> | Filepath to the output file\n");
    printf("    --input  -i <filepath> | Filepath to the input file\n");
#ifdef COMP_DEBUG
    printf("    --tokens               | Debug flag, print the tokens a list of tokens generated by the tokenizer\n");
    printf("    --ast                  | Debug flag, print the AST generated by the parser\n");
#endif // COMP_DEBUG
}

int main(int argc, char** argv){
#ifdef COMP_DEBUG
    bool printTokens = FALSE;
    bool printAST = FALSE;
#endif // COMP_DEBUG
    char* inFilepath = 0;
    char* outFilepath = "output.asm";
    for(int i = 0; i < argc; i++){
        if(strcmp(argv[i], "-o") == 0 || strcmp(argv[i], "--output") == 0){
            outFilepath = argv[i + 1];
            i++;
        }else if(strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--input") == 0){
            inFilepath = argv[i + 1];
            i++;
        }
#ifdef COMP_DEBUG
        else if(strcmp(argv[i], "--tokens") == 0){
            printTokens = TRUE;
        }else if(strcmp(argv[i], "--ast") == 0){
            printAST = TRUE;
        }
#endif // COMP_DEBUG
        else{
            if(argv[i][0] == '-'){
                printf("[ERROR] Argument \"%s\" not supported\n", argv[i]);
                usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
    }

    if(!inFilepath || !outFilepath){
        printf("[ERROR] Input filepath required\n");
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    // types
    TypeMapping typeMappings[] = {
        {.type = TYPE_U8,     .symbol = StringFromCstrLit("u8")},
        {.type = TYPE_U16,    .symbol = StringFromCstrLit("u16")},
        {.type = TYPE_U32,    .symbol = StringFromCstrLit("u32")},
        {.type = TYPE_U64,    .symbol = StringFromCstrLit("u64")},
        {.type = TYPE_S8,     .symbol = StringFromCstrLit("s8")},
        {.type = TYPE_S16,    .symbol = StringFromCstrLit("s16")},
        {.type = TYPE_S32,    .symbol = StringFromCstrLit("s32")},
        {.type = TYPE_S64,    .symbol = StringFromCstrLit("s64")},
        {.type = TYPE_F32,    .symbol = StringFromCstrLit("f32")},
        {.type = TYPE_F64,    .symbol = StringFromCstrLit("f64")},
        {.type = TYPE_STRING, .symbol = StringFromCstrLit("string")},
        {.type = TYPE_BOOL,   .symbol = StringFromCstrLit("bool")},
        {.type = TYPE_VOID,   .symbol = StringFromCstrLit("void")},
        
        {.type = TYPE_S64,    .symbol = StringFromCstrLit("int")},
        {.type = TYPE_F64,    .symbol = StringFromCstrLit("float")},
    };
    
    OperatorInfo opInfo[] = {
        {.symbol = StringFromCstrLit(">="), .precedence = 4, .behaviour = OP_TYPE_LOGICAL},
        {.symbol = StringFromCstrLit("<="), .precedence = 4, .behaviour = OP_TYPE_LOGICAL},
        {.symbol = StringFromCstrLit(">"),  .precedence = 4, .behaviour = OP_TYPE_LOGICAL},
        {.symbol = StringFromCstrLit("<"),  .precedence = 4, .behaviour = OP_TYPE_LOGICAL},
        {.symbol = StringFromCstrLit("!="), .precedence = 4, .behaviour = OP_TYPE_LOGICAL},
        {.symbol = StringFromCstrLit("=="), .precedence = 4, .behaviour = OP_TYPE_LOGICAL},
        
        {.symbol = StringFromCstrLit("+"), .precedence = 5,  .behaviour = OP_TYPE_ARITHMETIC},
        {.symbol = StringFromCstrLit("-"), .precedence = 5,  .behaviour = OP_TYPE_ARITHMETIC},
        {.symbol = StringFromCstrLit("*"), .precedence = 10, .behaviour = OP_TYPE_ARITHMETIC},
        {.symbol = StringFromCstrLit("/"), .precedence = 10, .behaviour = OP_TYPE_ARITHMETIC},
    };

    Arena readFileMem = {0}; // source file is stored in here
    String sourceRaw = EntireFileRead(&readFileMem, inFilepath);

    int filenameLen = strlen(inFilepath);
    String filename = {.str = inFilepath, .length = filenameLen};
    Tokenizer tokenizer = TokenizerInit(sourceRaw, filename, typeMappings, ARRAY_SIZE(typeMappings), opInfo, ARRAY_SIZE(opInfo));
    TokenArray tokens = Tokenize(&tokenizer);
#ifdef COMP_DEBUG
    if(printTokens) TokensPrint(&tokens);
#endif // COMP_DEBUG
    
    ParseContext parseContext = ParseContextInit(tokens, typeMappings, ARRAY_SIZE(typeMappings), opInfo, ARRAY_SIZE(opInfo));

    Scope* globalScope = Parse(&parseContext, &readFileMem);
#ifdef COMP_DEBUG
    if(printAST) ASTPrint(globalScope);
#endif // COMP_DEBUG

#if 0 // NOTE: tmp while doing typechecking
    GenContext genContext = GenContextInit(typeMappings, ARRAY_SIZE(typeMappings), opInfo, ARRAY_SIZE(opInfo));
    StringChain outRaw = Generate(&genContext, globalScope);

    bool success = EntireFileWrite(outFilepath, outRaw);
    if(!success){
        printf("[ERROR] Failed to write output asm file\n");
        exit(EXIT_FAILURE);
    }

    arena_free(&genContext.mem);
#endif
    arena_free(&readFileMem);
    exit(EXIT_SUCCESS);
}

// TODO: remove arenas from scope struct, all ast nodes and scope data should be allocated in one arena
// TODO: better error messeges when failing to parse an expresion

// TODO: implement a symetrical operation to parseing, reverseParse() that takes an AST and generates code,
// maintain multiple versions, to migrate from older versions of the code to newer,
// keep single parse() and reverseParse() function in separete compilation unit,
// and build with one depending the version, can be integrated into the build system to build and older version
// then migrate the code, then build the next version and reapead until the code is up to date
// this could be usefull later in development when standard libraries already exist and have to be updated
// with syntax changes
