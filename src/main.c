#include <stdio.h>  // fopen(), fseek(), ftell(), fread(), fclose(), printf(), 
#include <string.h> // strlen(), memcpy()
#include <assert.h> // assert()

#include "peWriter.h"
#include "bytecode_x86.h"
// #include "codegen.h"
#include "types.h"
#include "parser.h"
#include "lexer.h"
#include "string.h"
#include "common.h"

#define ARENA_IMPLEMENTATION
#include "arena.h"

String EntireFileRead(Arena* mem, String filePath) {
    FILE* f = fopen((char*)filePath.str, "rb");
    
    if(f){
        fseek(f, 0, SEEK_END);
        int fileSize = ftell(f);
        fseek(f, 0, SEEK_SET);
        
        u8* fileBuffer = arena_alloc(mem, fileSize * sizeof(u8));
        fread(fileBuffer, sizeof(char), fileSize, f);
        fclose(f);

        String str = {
            .str = fileBuffer,
            .length = fileSize,
        };
        return str;
    }else{
        printf("[ERROR] Failed to open file: "STR_FMT"\n", STR_PRINT(filePath));
        return (String){0};
    }
}

#if 0
bool EntireFileWrite(String filePath, StringChain data){
    FILE* f = fopen((char*)filePath.str, "wb");

    if(f){
        StringNode* current = data.first;
        while(current != NULL){
            fprintf(f, STR_FMT, STR_PRINT(current->str));
            current = current->next;
        }
        fclose(f);
        return TRUE;
    }else{
        printf("[ERROR] Failed to open file: "STR_FMT"\n", STR_PRINT(filePath));
        return FALSE;
    }
}
#else
bool EntireFileWrite(String filePath, Buffer data) {
    FILE* f = fopen((char*)filePath.str, "wb");

    if(f) {
        size_t res = fwrite(data.mem, 1, data.size, f);
        
        fclose(f);
        if(res != data.size) return FALSE;
        return TRUE;
    } else {
        printf("[ERROR] Failed to open file: "STR_FMT"\n", STR_PRINT(filePath));
        return FALSE;
    }
}
#endif

// 
// Main
// 

void usage(char* exePath){
    printf("Usage: %s [ARGS] -i <filepath>\n", exePath);
    printf("Supported args:\n");
    printf("    --output -o <filepath> | Filepath to the output file\n");
    printf("    --input  -i <filepath> | Filepath to the input file\n");
#ifdef COMP_DEBUG
    printf("    --tokens               | Debug flag, print the tokens a list of tokens generated by the tokenizer\n");
    printf("    --ast                  | Debug flag, print the AST generated by the parser\n");
#endif // COMP_DEBUG
}

int main(int argc, char** argv){
#ifdef COMP_DEBUG
    bool printTokens = FALSE;
    bool printAST = FALSE;
#endif // COMP_DEBUG
    String inFilepath = {0};
    String outFilepath = STR("output.asm");
    for(int i = 0; i < argc; i++){
        if(strcmp(argv[i], "-o") == 0 || strcmp(argv[i], "--output") == 0){
            outFilepath = STR(argv[i + 1]);
            i++;
        }else if(strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--input") == 0){
            inFilepath = STR(argv[i + 1]);
            i++;
        }
#ifdef COMP_DEBUG
        else if(strcmp(argv[i], "--tokens") == 0){
            printTokens = TRUE;
        }else if(strcmp(argv[i], "--ast") == 0){
            printAST = TRUE;
        }
#endif // COMP_DEBUG
        else{
            if(argv[i][0] == '-'){
                printf("[ERROR] Argument \"%s\" not supported\n", argv[i]);
                usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
    }

    if(inFilepath.length == 0 || outFilepath.length == 0){
        printf("[ERROR] Input filepath required\n");
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    Arena readFileMem = {0}; // source file is stored in here
    String sourceRaw = EntireFileRead(&readFileMem, inFilepath);

    TokenArray tokens = Tokenize(sourceRaw, inFilepath);
#ifdef COMP_DEBUG
    if(printTokens) TokensPrint(&tokens);
#endif // COMP_DEBUG
    
    ParseResult parseResult = Parse(tokens, &readFileMem);
#ifdef COMP_DEBUG
    if(printAST) ASTPrint(parseResult.globalScope);
#endif // COMP_DEBUG

    #if 1
    GenContext bytecode = gen_x86_64_bytecode(parseResult.globalScope, parseResult.funcInfo);

    if(StringEndsWith(outFilepath, STR(".bin"))) {
        if(!EntireFileWrite(outFilepath, bytecode.code)) {
            printf("[ERROR] Failed to write output file: "STR_FMT"\n", STR_PRINT(outFilepath));
            exit(EXIT_FAILURE);
        }
    } else if(StringEndsWith(outFilepath, STR(".exe"))) {
        Buffer exeBytes = genExecutable(&parseResult.importLibraries, bytecode.code, bytecode.symbolsToPatch, &bytecode.data, bytecode.dataToPatch);
        // genExecutable(bytecode.code, bytecode.entryPointOffset, libs, bytecode.symbolsToPatch, &bytecode.data, bytecode.dataToPatch);
        // genExecutable(bytecode, entryPointOffset, symbolsToImport, symbolsToPatch, userData, userDataToPatch)
        if(!EntireFileWrite(outFilepath, exeBytes)) {
            printf("[ERROR] Failed to write output file: "STR_FMT"\n", STR_PRINT(outFilepath));
            exit(EXIT_FAILURE);
        }
    } else {
        s64 index = StringLastIndexOf(outFilepath, '.');
        String format = {0};
        if(index >= 0) {
            format.str = &outFilepath.str[index];
            format.length = outFilepath.length - index;
        } else {
            format = STR("unknown");
        }
        printf("[ERROR] unsupported target format: "STR_FMT"\n", STR_PRINT(format));
        exit(EXIT_FAILURE);
    }
    #endif

#if 0 // NOTE: tmp while doing typechecking
    GenContext genContext = {0};
    StringChain outRaw = Generate(&genContext, globalScope);

    bool success = EntireFileWrite(outFilepath, outRaw);
    if(!success){
        printf("[ERROR] Failed to write output asm file\n");
        exit(EXIT_FAILURE);
    }

    arena_free(&genContext.mem);
#endif
    arena_free(&readFileMem);
    exit(EXIT_SUCCESS);
}

// TODO: remove arenas from scope struct, all ast nodes and scope data should be allocated in one arena
// TODO: better error messeges when failing to parse an expression

// TODO: implement a symetrical operation to parsing, reverseParse() that takes an AST and generates code,
// maintain multiple versions, to migrate from older versions of the code to newer,
// keep single parse() and reverseParse() function in separete compilation unit,
// and build with one depending the version, can be integrated into the build system to build and older version
// then migrate the code, then build the next version and reapead until the code is up to date
// this could be useful later in development when standard libraries already exist and have to be updated
// with syntax changes

// TODO: maybe having an else and elseif ast node doesnt make sense
// just store all the conditions and their coresponding scopes
// in an array, and tag the node if it has an else/elseif block
