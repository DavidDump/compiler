#include <stdio.h>  // fopen(), fseek(), ftell(), fread(), fclose(), printf(), 
#include <string.h> // strlen(), memcpy()

#define DATA_STRUCT_IMPLEMENTATION
#include "dataStructures.h"
#undef DATA_STRUCT_IMPLEMENTATION

#include "peWriter.h"
#include "bytecode_x86.h"
#include "parser.h"
#include "lexer.h"
#include "string.h"
#include "common.h"

#define ARENA_IMPLEMENTATION
#include "arena.h"

String EntireFileRead(Arena* mem, String filePath) {
    FILE* f = fopen((char*)filePath.str, "rb");
    
    if(f){
        fseek(f, 0, SEEK_END);
        int fileSize = ftell(f);
        fseek(f, 0, SEEK_SET);
        
        u8* fileBuffer = arena_alloc(mem, fileSize * sizeof(u8));
        fread(fileBuffer, sizeof(char), fileSize, f);
        fclose(f);

        String str = {
            .str = fileBuffer,
            .length = fileSize,
        };
        return str;
    }else{
        printf("[ERROR] Failed to open file: "STR_FMT"\n", STR_PRINT(filePath));
        return (String){0};
    }
}

bool EntireFileWrite(String filePath, Array(u8) data) {
    FILE* f = fopen((char*)filePath.str, "wb");

    if(f) {
        size_t res = fwrite(data.data, 1, data.size, f);
        
        fclose(f);
        if(res != data.size) return FALSE;
        return TRUE;
    } else {
        printf("[ERROR] Failed to open file: "STR_FMT"\n", STR_PRINT(filePath));
        return FALSE;
    }
}

// 
// Main
// 

void usage(char* exePath){
    printf("Usage: %s [ARGS] -i <filepath>\n", exePath);
    printf("Supported args:\n");
    printf("    --output -o <filepath> | Filepath to the output file\n");
    printf("    --input  -i <filepath> | Filepath to the input file\n");
#ifdef COMP_DEBUG
    printf("    --tokens               | Debug flag, print the tokens a list of tokens generated by the tokenizer\n");
    printf("    --ast                  | Debug flag, print the AST generated by the parser\n");
#endif // COMP_DEBUG
}

int main(int argc, char** argv){
#ifdef COMP_DEBUG
    bool printTokens = FALSE;
    bool printAST = FALSE;
#endif // COMP_DEBUG
    String inFilepath = {0};
    String outFilepath = STR("output.asm");
    for(int i = 0; i < argc; i++){
        if(strcmp(argv[i], "-o") == 0 || strcmp(argv[i], "--output") == 0){
            char* name = argv[i + 1];
            u64 len = strlen(name);
            outFilepath.str = (u8*)name;
            outFilepath.length = len;
            i++;
        }else if(strcmp(argv[i], "-i") == 0 || strcmp(argv[i], "--input") == 0){
            char* name = argv[i + 1];
            u64 len = strlen(name);
            inFilepath.str = (u8*)name;
            inFilepath.length = len;
            i++;
        }
#ifdef COMP_DEBUG
        else if(strcmp(argv[i], "--tokens") == 0){
            printTokens = TRUE;
        }else if(strcmp(argv[i], "--ast") == 0){
            printAST = TRUE;
        }
#endif // COMP_DEBUG
        else{
            if(argv[i][0] == '-'){
                printf("[ERROR] Argument \"%s\" not supported\n", argv[i]);
                usage(argv[0]);
                exit(EXIT_FAILURE);
            }
        }
    }

    if(inFilepath.length == 0 || outFilepath.length == 0){
        printf("[ERROR] Input filepath required\n");
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    Arena readFileMem = {0}; // source file is stored in here
    String sourceRaw = EntireFileRead(&readFileMem, inFilepath);

    Array(Token) tokens = Tokenize(&readFileMem, sourceRaw, inFilepath);
#ifdef COMP_DEBUG
    if(printTokens) TokensPrint(&tokens);
#endif // COMP_DEBUG
    
    ParseResult parseResult = Parse(tokens, &readFileMem);
#ifdef COMP_DEBUG
    if(printAST) ASTPrint(parseResult.globalScope);
#endif // COMP_DEBUG

    GenContext bytecode = gen_x86_64_bytecode(parseResult.globalScope, parseResult.funcInfo);
    if(StringEndsWith(outFilepath, STR(".bin"))) {
        if(!EntireFileWrite(outFilepath, bytecode.code)) {
            printf("[ERROR] Failed to write output file: "STR_FMT"\n", STR_PRINT(outFilepath));
            exit(EXIT_FAILURE);
        }
    } else if(StringEndsWith(outFilepath, STR(".exe"))) {
        Array(u8) exeBytes = genExecutable(&parseResult.importLibraries, bytecode.code, bytecode.symbolsToPatch, &bytecode.data, bytecode.dataToPatch, &bytecode.functions, bytecode.functionsToPatch, bytecode.entryPointOffset);
        if(!EntireFileWrite(outFilepath, exeBytes)) {
            printf("[ERROR] Failed to write output file: "STR_FMT"\n", STR_PRINT(outFilepath));
            exit(EXIT_FAILURE);
        }
    } else {
        s64 index = StringLastIndexOf(outFilepath, '.');
        String format = {0};
        if(index >= 0) {
            format.str = &outFilepath.str[index];
            format.length = outFilepath.length - index;
        } else {
            format = STR("unknown");
        }
        printf("[ERROR] unsupported target format: "STR_FMT"\n", STR_PRINT(format));
        exit(EXIT_FAILURE);
    }

    arena_free(&readFileMem);
    exit(EXIT_SUCCESS);
}

// TODO: remove arenas from scope struct, all ast nodes and scope data should be allocated in one arena

// TODO: implement a symetrical operation to parsing, reverseParse() that takes an AST and generates code,
// maintain multiple versions, to migrate from older versions of the code to newer,
// keep single parse() and reverseParse() function in separete compilation unit,
// and build with one depending the version, can be integrated into the build system to build and older version
// then migrate the code, then build the next version and reapead until the code is up to date
// this could be useful later in development when standard libraries already exist and have to be updated
// with syntax changes

// TODO: write own memory allocator, this one has a bug in it when allocating more memory that fits on one page
